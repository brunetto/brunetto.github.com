<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Simulations on Post It!</title>
    <link>http://brunettoziosi.eu/tags/simulations/</link>
    <description>Recent content in Simulations on Post It!</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 20 Aug 2013 09:34:11 +0000</lastBuildDate>
    <atom:link href="http://brunettoziosi.eu/tags/simulations/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>StarLab-GPU installation</title>
      <link>http://brunettoziosi.eu/posts/starlab-gpu-installation/</link>
      <pubDate>Tue, 20 Aug 2013 09:34:11 +0000</pubDate>
      
      <guid>http://brunettoziosi.eu/posts/starlab-gpu-installation/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../pages/research/utils/starlab-gpu-old-guide&#34;&gt;Click here for the old guide!!!&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;2014/09/16: updated with installation instruction for g2@Swinburne and some troubleshooting.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;UPDATE 2:&lt;/strong&gt; &lt;strong&gt;&lt;a href=&#34;../dockerized-starlab/&#34;&gt;new post&lt;/a&gt;&lt;/strong&gt; about installing and using StarLab in a Docker container!!
Less troubles, more reproducibility!!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;UPDATE:&lt;/strong&gt; if you want to compile starlab &lt;strong&gt;without GPU support&lt;/strong&gt;, you only need to&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ignore the &amp;ldquo;&lt;code&gt;sapporo&lt;/code&gt;&amp;rdquo;  and &amp;ldquo;&lt;code&gt;CUDA&lt;/code&gt;&amp;rdquo; instructions&lt;/li&gt;
&lt;li&gt;rename &lt;code&gt;starlab/local/grape.sh&lt;/code&gt; to &lt;code&gt;starlab/local/_grape.sh&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;substitute &lt;code&gt;configure --without-f77&lt;/code&gt; with &lt;code&gt;configure --with-grape=no --without-f77&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;in case you can&amp;rsquo;t &lt;code&gt;make&lt;/code&gt; succesfully may be you need to copy the folder
&lt;code&gt;starlab/src/gfx&lt;/code&gt; and do not make clean&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;Well, probably you landed here searching information about StarLab, how to
install it, how to run it, how prevent it to harm your cat.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DISCLAIMER 1:&lt;/strong&gt; I won&amp;rsquo;t promise anything about your cat but I will try to help you having a
reasonable well running installation of StarLab.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DISCLAIMER 2:&lt;/strong&gt; I&amp;rsquo;m not a programmer, I&amp;rsquo;m not a system administrator and I don&amp;rsquo;t even
know how to program in CUDA (yet). Maybe something here is wrong ore outdated.
I&amp;rsquo;m only giving you some of the experienced I collected in n+1 times I installed StarLab.
Nothin less, nothing more.&lt;br /&gt;
Also note that most of the knowledge I put here come
from my &lt;a href=&#34;http://web.pd.astro.it/mapelli/&#34;&gt;supervisor&lt;/a&gt;.&lt;br /&gt;
I also thanks Mario Spera for the usefull advices.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DISCLAIMER 3:&lt;/strong&gt; StarLab still seems to &lt;strong&gt;always&lt;/strong&gt; crash if you try to simulate a system
with more than ~6000 binaries.&lt;/p&gt;

&lt;h2 id=&#34;starlab:78&#34;&gt;StarLab&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.sns.ias.edu/~starlab/&#34;&gt;StarLab&lt;/a&gt; is &amp;ldquo;A Software Environment for Collisional Stellar Dynamics&amp;rdquo;.
&lt;a href=&#34;http://www.sns.ias.edu/~starlab/&#34;&gt;Here&lt;/a&gt; you can find useful information about it that
is not useful to rewrite here, so have a look and then come back!:)&lt;/p&gt;

&lt;h2 id=&#34;starlab-gpu:78&#34;&gt;StarLab-GPU&lt;/h2&gt;

&lt;p&gt;Welcome back!!&lt;br /&gt;
Next step: StarLab was designed to run on &lt;a href=&#34;http://en.wikipedia.org/wiki/Gravity_Pipe&#34;&gt;GRAPE&lt;/a&gt;
but thanks to the &lt;a href=&#34;http://castle.strw.leidenuniv.nl/software/sapporo.html&#34;&gt;Sapporo&lt;/a&gt;
library you can run it on GPUs.&lt;/p&gt;

&lt;p&gt;Now we will try to install a GPU-ready version of StarLab. To be honest, we run
a &lt;strong&gt;private&lt;/strong&gt; version of StarLab for GPU with some customizations (if you are interested,
see &lt;a href=&#34;http://arxiv.org/abs/1211.6441&#34;&gt;Mapelli et al. 2013&lt;/a&gt;; &lt;a href=&#34;http://arxiv.org/abs/1301.4227&#34;&gt;Mapelli &amp;amp; Bressan 2013&lt;/a&gt;).&lt;br /&gt;
Unfortunately you can&amp;rsquo;t download it now, but I hope the differences in the installation
process are negligible. Ask us if you are interested in our version of StarLab.&lt;br /&gt;
Because I&amp;rsquo;m not sure about what you will find in the public version os Sapporo and StarLab,
I will show my version of the relevant files you need to install everything.
The installation is done on a Ubuntu 14.04 workstation so change them accordingly to
your OS. I will also provide some examples on what you need to install StarLab on
the clusters I tested.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s start!!&lt;/p&gt;

&lt;h4 id=&#34;download:78&#34;&gt;Download&lt;/h4&gt;

&lt;p&gt;Be sure you have boost libraries, nVidia driver and CUDA correctly installed.
You can try to check them using&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;locate cuda | grep nvcc&lt;/code&gt; (cuda compiler)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;locate cuda | grep include&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;locate cuda | grep include | grep toolkit&lt;/code&gt; (for the SDK files of the new release)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;locate cuda | grep lib | grep cudart&lt;/code&gt; (CUDA runtime)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;locate cuda | boost lib&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;locate cuda | boost include&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It could be also useful to have a copy of the old CUDA SDK. Yes, I know, it&amp;rsquo;s a mess,
but it&amp;rsquo;s not my fault!:P&lt;/p&gt;

&lt;p&gt;Download&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.sns.ias.edu/~starlab/download/starlab.tar.gz&#34;&gt;StarLab&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://castle.strw.leidenuniv.nl/documents/Sapporo/sapporo161.tgz&#34;&gt;Sapporo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;and decompress the archives with &lt;code&gt;tar -xvf archiveName&lt;/code&gt;.&lt;br /&gt;
Try to have the following folder tree:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$SLPATH/slpack&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$SLPATH/slpack/NVIDIA&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$SLPATH/slpack/NVIDIA/NVIDIA_CUDA-5.0_Samples&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$SLPATH/slpack/NVIDIA/NVIDIA_GPU_Computing_SDK&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$SLPATH/slpack/sapporo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$SLPATH/slpack/starlab&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The NVIDIA folder is optional, but I would suggest to have with you alle the NVIDIA
file you can find, soon or later you will need them. CUDA is continuosly changing,
SDK is not toolkit, dependencies are different and broken between different versions.
We will try to survive and to have the most standard installation we can.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$SLPATH&lt;/code&gt; should be the path where you put your StarLab installation.&lt;br /&gt;
I&amp;rsquo;m not sure about what you will find in the public version of StarLab and Sapporo.&lt;/p&gt;

&lt;h3 id=&#34;sapporo:78&#34;&gt;Sapporo&lt;/h3&gt;

&lt;p&gt;Enter in the sapporo folder, and to be sure to start a clean installation run
&lt;code&gt;make clean&lt;/code&gt;.
Here you need to find:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Makefile&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compile.sh&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;host_evaluate_gravity.cu&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;compile.sh&lt;/code&gt; is the script StarLab will run later to decide if you are worthy of
its presence in your computer. If &lt;code&gt;compile.sh&lt;/code&gt; fail, StarLab won&amp;rsquo;t install.&lt;/p&gt;

&lt;p&gt;You also need to find somewhere (= in an old CUDA SKD?)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cutil.h&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;multithreading.h&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;and to copy them in this folder.&lt;br /&gt;
If you are not able to find them, ask me, I have copies of those files.&lt;/p&gt;

&lt;p&gt;Open &lt;code&gt;host_evaluate_gravity.cu&lt;/code&gt; and change&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#include &amp;lt;cutil.h&amp;gt;
#include &amp;lt;multithreading.h&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#include &amp;quot;cutil.h&amp;quot;
#include &amp;quot;multithreading.h&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is to make Sapporo read the local version of &lt;code&gt;cutil.h&lt;/code&gt; and &lt;code&gt;multithreading.h&lt;/code&gt;
in case your CUDA version does not support them anymore.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s time to fix a bug (thanks Mario):
in &lt;code&gt;sapporo.cpp&lt;/code&gt; change&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;		fprintf(stderr, &amp;quot;\n&amp;quot;);
		nCUDAdevices = how_many;
    } else {
		fprintf(stderr,&amp;quot; sapporo::open - no config file is found \n&amp;quot;);
		fprintf(stderr,&amp;quot;  using all %d CUDA device(s), nj_max= %d\n&amp;quot;, nCUDAdevices, nj_max);
		//Set original_how_many to a positive number so we get assigned different devices
		//incase the devices are not in compute exclusive mode.
		original_how_many = 1;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;		fprintf(stderr, &amp;quot;\n&amp;quot;);
		nCUDAdevices = how_many;
		fclose(fd); // thanks Mario Spera, without this SL will crash after a while if using sapporo.config
  } else {
    fprintf(stderr,&amp;quot; sapporo::open - no config file is found \n&amp;quot;);
    fprintf(stderr,&amp;quot;  using all %d CUDA device(s), nj_max= %d\n&amp;quot;, nCUDAdevices, nj_max);
    //Set original_how_many to a positive number so we get assigned different devices
    //incase the devices are not in compute exclusive mode.
    original_how_many = 1;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;so the &lt;code&gt;sapporo.config&lt;/code&gt; file can be close and won&amp;rsquo;t crash your run.&lt;/p&gt;

&lt;p&gt;Now open &lt;code&gt;Makefile&lt;/code&gt; and fit&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Makefile&#34;&gt;CXX  := g++
CC   := gcc
NVCC := /usr/bin/nvcc
CUDAPATH    := /usr/include/
CUDAINCLUDE := -I$(CUDAPATH) 
BOOSTPATH := /usr/include/boost 
BOOSTINCLUDE := -I$(BOOSTPATH)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to your case.&lt;br /&gt;
Open &lt;code&gt;compile.sh&lt;/code&gt; and be sure to have something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/sh

flags=-DNGB

CUDAINC=&amp;quot;-I/usr/include -I/usr/lib/nvidia-cuda-toolkit/include/&amp;quot;
CUDALIB=&amp;quot;-L/usr/lib/x86_64-linux-gnu/&amp;quot;
CUDAFLAG=&amp;quot;-lcudart&amp;quot;
BOOSTINC=&amp;quot;-I/usr/include/boost&amp;quot;
BOOSTLIB=&amp;quot;-L/usr/lib/x86_64-linux-gnu/&amp;quot;
BOOSTFLAG=&amp;quot;-lboost_system -lboost_thread -lpthread&amp;quot;


g++ -O3 $flags -g -o test_gravity_block test_gravity_block.cpp -L. -lsapporo $CUDAINC $CUDALIB $CUDAFLAG $BOOSTINC $BOOSTLIB $BOOSTFLAG
g++ -O3 $flags -g -o test_gravity_N2ngb test_gravity_N2ngb.cpp -L. -lsapporo $CUDAINC $CUDALIB $CUDAFLAG $BOOSTINC $BOOSTLIB $BOOSTFLAG
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Try to compile with &lt;code&gt;make&lt;/code&gt;. If it works, try to tun &lt;code&gt;bash compile.sh&lt;/code&gt;. If this works too,
then test sapporo with&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;./test_gravity_block 800&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;./test_gravity_block 800&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Be aware that a number (of particles) too small would crash the tests.&lt;/p&gt;

&lt;p&gt;Assuming &lt;code&gt;sapporo&lt;/code&gt; is ready, let&amp;rsquo;s move to starlab.&lt;/p&gt;

&lt;h3 id=&#34;starlab-1:78&#34;&gt;StarLab&lt;/h3&gt;

&lt;p&gt;In StarLab the relevant files you have to worry about are&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sbin/sqrt.c&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;configure&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;local/grape.sh&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Rename &lt;code&gt;sbin/sqrt.c&lt;/code&gt; to &lt;code&gt;sbin/sqrt.C&lt;/code&gt; otherwise
you could have linker problems again the C math library.&lt;br /&gt;
Now open &lt;code&gt;configure&lt;/code&gt; and search for CUDA. Probably you won&amp;rsquo;t find anything.&lt;br /&gt;
Search for &lt;code&gt;Check all named libraries for g6_open&lt;/code&gt;, you should find something like&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#   Check all named libraries for g6_open() (GRAPE-6).

    grape6=no

    for gl in $GRAPE_LIBS_; do
        as_ac_Lib=`echo &amp;quot;ac_cv_lib_${gl/-l/}&#39;&#39;_g6_open_&amp;quot; | $as_tr_sh`
echo &amp;quot;$as_me:$LINENO: checking for g6_open_ in -l${gl/-l/}&amp;quot; &amp;gt;&amp;amp;5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;modify it to include boost and CUDA like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;for gl in $GRAPE_LIBS_; do
	CUDAINC=&amp;quot;-I/usr/include -I/usr/lib/nvidia-cuda-toolkit/include/&amp;quot;
	CUDALIB=&amp;quot;-L/usr/lib/x86_64-linux-gnu/&amp;quot;
	CUDAFLAG=&amp;quot;-lcudart&amp;quot;
	BOOSTINC=&amp;quot;-I/usr/include/boost/&amp;quot;
	BOOSTLIB=&amp;quot;-L/usr/lib/x86_64-linux-gnu/&amp;quot;
	BOOSTFLAG=&amp;quot;-lboost_system -lboost_thread -lpthread&amp;quot;
	
	LIBS=&amp;quot;$CUDAINC $CUDALIB $CUDAFLAG $BOOSTINC $BOOSTLIB $BOOSTFLAG -DNGB&amp;quot;
		
	as_ac_Lib=`echo &amp;quot;ac_cv_lib_${gl/-l/}&#39;&#39;_g6_open_&amp;quot; | $as_tr_sh`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Be sure to always use double quotes and to terminate the paths to folders with a slash (&lt;code&gt;/&lt;/code&gt;),
some machines are quite choosy.&lt;/p&gt;

&lt;p&gt;Last edit is on &lt;code&gt;local/grape.sh&lt;/code&gt; to let StarLab know where your sapporo installation is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;GRAPE_LDFLAGS_=&#39;-L$SLPATH/slpack/sapporo&#39;
GRAPE_LIBS_=&#39;-lsapporo&#39;
# For now, define this as `yes&#39; for the AMD64 boxes only, `no&#39; otherwise.
OLD_READ_NEIGHBOUR_LIST=no
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before compiling, if you want, you can check also &lt;code&gt;sapporo/sapporo.config&lt;/code&gt;.&lt;br /&gt;
Inside you will find something like that:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;524288
-1
0
1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where 524288 should be the maximum number of particles you can handle, -1 the number
of CUDA devices to use (-1 means all? maybe&amp;hellip;), 0 and 1 are the GPU number you want to use.&lt;br /&gt;
Recent CUDA seems to be smart enought to understand where to run without having to specify
(but look after your cat!!!).&lt;/p&gt;

&lt;p&gt;Alright!! If you managed to reach this point, very good. Last three commands. In the
&lt;code&gt;starlab&lt;/code&gt; folder run&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;configure --with-f77=no&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;make&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;go out for a walk&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;make install&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When running configure, avoid the &lt;code&gt;--without-option&lt;/code&gt; version of an option, prefer
&lt;code&gt;--with-option=no&lt;/code&gt;, it&amp;rsquo;s safer.&lt;/p&gt;

&lt;p&gt;If you recompile StarLab AND/OR Sapporo, type &lt;code&gt;make clean&lt;/code&gt; two times. delete the files in
&lt;code&gt;starlab/usr/bin&lt;/code&gt;, turn around 3 times, touch your nose and type &lt;code&gt;make&lt;/code&gt; two times. Then
&lt;code&gt;make install&lt;/code&gt; again.&lt;br /&gt;
No, &lt;code&gt;make clean&lt;/code&gt; and &lt;code&gt;make&lt;/code&gt; are not enought to update your object
files or binaries.&lt;/p&gt;

&lt;p&gt;Depending on your environment, if you run into problems, be sure that:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;you loaded the correct modules (if you are in a cluster for examples&lt;/li&gt;
&lt;li&gt;you are into the right node (some machine let you compile your code on a
node that is not the login node)&lt;/li&gt;
&lt;li&gt;if you encounter strange messages regarding missing rules for missing files,
for example &lt;code&gt;libxhdyn.la&lt;/code&gt; or something regarding &lt;code&gt;gfx&lt;/code&gt;-something, may be tou need to
tune your config file to exclude, for example, the X/Qt/&amp;hellip; libraries, in case
try to run &lt;code&gt;configure --with-f77=no --with-qt=no&lt;/code&gt;; in case try to have a look at
&lt;code&gt;configure --help&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;run-starlab:78&#34;&gt;Run StarLab&lt;/h3&gt;

&lt;p&gt;Before run a simulation you need to create the initial conditions.&lt;/p&gt;

&lt;h4 id=&#34;initial-conditions:78&#34;&gt;Initial Conditions&lt;/h4&gt;

&lt;p&gt;StarLab is provided with few tools to help (really?) you in this task. A common
way to create ICs for &lt;a href=&#34;http://arxiv.org/abs/1404.7147&#34;&gt;our simulations&lt;/a&gt; is something like:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;ehm, I don&#39;t know if I can tell you, sorry man...:(&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;launch:78&#34;&gt;Launch&lt;/h4&gt;

&lt;p&gt;StarLab read ICs from the STDIN, write the output snapshots to STDOUT and everything
you want to know about your simulations to STDERR, so, &lt;code&gt;&amp;lt;ehm.... see ICs&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;tidal-fields:78&#34;&gt;Tidal fields&lt;/h4&gt;

&lt;p&gt;Be patience&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;known-issues-and-troubleshooting:78&#34;&gt;Known issues and Troubleshooting&lt;/h3&gt;

&lt;p&gt;If StarLab did not kill your cat in a horrile way, then, it can still ruin your life.&lt;br /&gt;
Some of the things that can happen are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;you can find binaries with eccentricity greater than one (StarLab does
not update some binaries after they are disrupted? flybyes seen as binaries? don&amp;rsquo;t know)&lt;/li&gt;
&lt;li&gt;StarLab can crash if you try to simulate a number of centers of mass greater than
5*10^4 together with a fraction of primordial binaries &amp;gt;=0.1&lt;/li&gt;
&lt;li&gt;boost problems? check the correct flags for your version (choose among some combination of
&lt;code&gt;-lboost_system, -lboost_system-mt, -lboost_thread, -lpthread&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;check you put all the &lt;code&gt;_&lt;/code&gt;, &amp;ldquo;-I&amp;rdquo;, &amp;ldquo;-l&amp;rdquo;, &amp;ldquo;-L&amp;rdquo; in the right places&lt;/li&gt;
&lt;li&gt;check all the libraries paths&lt;/li&gt;
&lt;li&gt;check for double quotes (&lt;code&gt;&amp;quot;&lt;/code&gt;) instead of single ones (&lt;code&gt;&#39;&lt;/code&gt;) in the paths&lt;/li&gt;
&lt;li&gt;check the modules, environment variables&lt;/li&gt;
&lt;li&gt;check you are on the right node&lt;/li&gt;
&lt;li&gt;check your environment against the configure options you passed
(have a look at &lt;code&gt;configure --help&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;if you need to modify StarLab and you want to add your own flags,
you need to comment&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;  getia(b-&amp;gt;get_log_story(), &amp;quot;step_slow&amp;quot;,
        b-&amp;gt;get_kira_counters()-&amp;gt;step_slow, nss);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;function call in &lt;code&gt;kira_counters.C&lt;/code&gt; otherwise you won&amp;rsquo;t be able to compile StarLab.&lt;/p&gt;

&lt;h3 id=&#34;clusters:78&#34;&gt;Clusters&lt;/h3&gt;

&lt;h4 id=&#34;eurora:78&#34;&gt;EURORA&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;in &lt;code&gt;setup_sapporo.sh&lt;/code&gt;
(if you want to compile sapporo using queues, or, load modules by hand if you want to
compile interactively)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;module purge
module load profile/advanced
module load gnu/4.6.3
module load boost/1.53.0--gnu--4.6.3
module load cuda

LD_LIBRARY_PATH=/cineca/prod/compilers/cuda/5.0.35/none/lib64:/cineca/prod/libraries/boost/1.53.0/gnu--4.6.3/lib
export LD_LIBRARY_PATH
cd $HOME/slPack/sapporo
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;in &lt;code&gt;compile.sh&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;CUDAINC=&amp;quot;-I/cineca/prod/compilers/cuda/5.0.35/none/include/ -I/cineca/prod/compilers/cuda/5.0.35/none/samples/common/inc/ -I/cineca/prod/libraries/boost/1.53.0/gnu--4.6.3/include/&amp;quot;
CUDALIB=&amp;quot;-L/cineca/prod/compilers/cuda/5.0.35/none/lib64 -L/cineca/prod/libraries/boost/1.53.0/gnu--4.6.3/lib -lcudart&amp;quot;
g++ -O3 $flags -g -o test_gravity_block test_gravity_block.cpp -L. -lsapporo $CUDAINC $CUDALIB -lboost_thread-mt
g++ -O3 $flags -g -o test_gravity_N2ngb test_gravity_N2ngb.cpp -L. -lsapporo $CUDAINC $CUDALIB -lboost_thread-mt
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;in &lt;code&gt;Makefile&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;NVCC := /cineca/prod/compilers/cuda/5.0.35/none/bin/nvcc
CUDAPATH    := /cineca/prod/compilers/cuda/5.0.35/none
CUDASDKPATH := /cineca/prod/compilers/cuda/5.0.35/none/samples
CUDAINCLUDE := -I$(CUDAPATH)/include -I$(CUDASDKPATH)/common/inc 
BOOSTPATH := /cineca/prod/libraries/boost/1.53.0/gnu--4.6.3/include
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;in &lt;code&gt;configure&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;CUDAINC=&amp;quot;-I/cineca/prod/compilers/cuda/5.0.35/none/include -I/cineca/prod/compilers/cuda/5.0.35/none/samples/common/inc -I/cineca/prod/libraries/boost/1.53.0/gnu--4.6.3/include/&amp;quot;
CUDALIB=&amp;quot;-L/cineca/prod/compilers/cuda/5.0.35/none/lib64 -lcudart&amp;quot; 
LIBS=&amp;quot;$CUDAINC $CUDALIB -L/cineca/prod/libraries/boost/1.53.0/gnu--4.6.3/lib -lboost_thread-mt -DNGB&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;in &lt;code&gt;grape.sh&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;GRAPE_LDFLAGS_=&#39;-L$HOME/slPack/sapporo/&#39;
GRAPE_LIBS_=&#39;-lsapporo&#39;

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;in &lt;code&gt;setup_starlab.sh.sh&lt;/code&gt;
(if you want to compile sapporo using queues, or, load modules by hand if you want to
compile interactively)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;module purge
module load profile/advanced
module load gnu/4.6.3
module load boost/1.53.0--gnu--4.6.3
module load cuda
LD_LIBRARY_PATH=/cineca/prod/compilers/cuda/5.0.35/none/lib64:/cineca/prod/libraries/boost/1.53.0/gnu--4.6.3/lib
export LD_LIBRARY_PATH
cd $HOME/slPack/starlab
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;green-ii-hpc-system-swinburne-university:78&#34;&gt;Green II HPC system @ Swinburne University&lt;/h4&gt;

&lt;p&gt;Thanks to prof. Jarrod Hurley I was able to test the installation of StarLab on the Green II HPC
system at the Swinburne University. Here how to do that.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Log into the system and find yourself in the login node.&lt;/li&gt;
&lt;li&gt;Clone the private repo / download the folders and unpack them like described before.&lt;/li&gt;
&lt;li&gt;Then you need to log into one of the compile/test nodes from the head node: &lt;code&gt;ssh $USER@gstar001&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;load the right modules:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;module load gcc/4.6.4
module load boost/x86_64/gnu/1.51.0-gcc4.6
module load cuda/4.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You need that version of &lt;code&gt;gcc&lt;/code&gt; and &lt;code&gt;boost&lt;/code&gt; because of issues with boost threads in the default versions.
Just in case, check that the paths in the &lt;code&gt;Makefile&lt;/code&gt; and &lt;code&gt;compile.h&lt;/code&gt; agree with that shown in&lt;br /&gt;
&lt;code&gt;module show boost/x86_64/gnu/1.51.0-gcc4.6&lt;/code&gt;
and
&lt;code&gt;module show cuda&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Make sure you have no &lt;code&gt;&#39;&lt;/code&gt; around your path, maybe, if you need, only &lt;code&gt;&amp;quot;&lt;/code&gt; otherwise &lt;code&gt;sapporo&lt;/code&gt; won&amp;rsquo;t compile.
Just in case, check that the paths in the &lt;code&gt;Makefile&lt;/code&gt; and &lt;code&gt;compile.h&lt;/code&gt; agree with that shown in&lt;br /&gt;
&lt;code&gt;module show boost/x86_64/gnu/1.51.0-gcc4.6&lt;/code&gt;
and
&lt;code&gt;module show cuda&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;If you have our private version you can
* &lt;code&gt;cp ../scripts/g2/Makefile ./&lt;/code&gt;
* &lt;code&gt;cp ../scripts/g2/compile.sh ./&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;otherwise try to modify them to have:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;CXX  := g++
CC   := gcc
NVCC := /usr/local/cuda-4.0/bin/nvcc
CUDAINC := -I/usr/local/cuda-4.0/include -I/usr/local/cuda-4.0/C/common/inc 
BOOSTINC := -I/usr/local/x86_64/gnu/boost-1.51.0-gcc4.6
NVCCFLAGS := -O0 -g -D_DEBUG  -maxrregcount=64 $(CUDAINC) $(BOOSTINC) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in the &lt;code&gt;Makefile&lt;/code&gt; and&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;flags=-DNGB

CUDAINC=&amp;quot;-I/usr/local/cuda-4.0/include -I/usr/local/cuda-4.0/C/common/inc&amp;quot;
CUDALIB=&amp;quot;-L/usr/local/cuda-4.0/lib64 -L/usr/local/cuda-4.0/lib:/usr/local/cuda-4.0/C/lib&amp;quot;
CUDAFLAG=&amp;quot;-lcudart&amp;quot;
BOOSTINC=&amp;quot;-I/usr/local/x86_64/gnu/boost-1.51.0-gcc4.6&amp;quot;
BOOSTLIB=&amp;quot;-L/usr/local/x86_64/gnu/boost-1.51.0-gcc4.6&amp;quot;
BOOSTFLAG=&amp;quot;-lboost_system  -lboost_thread-mt -lpthread&amp;quot;

g++ -O3 $flags -g -o test_gravity_block test_gravity_block.cpp -L. -lsapporo $CUDAINC $CUDALIB $CUDAFLAG $BOOSTINC $BOOSTLIB $BOOSTFLAG
g++ -O3 $flags -g -o test_gravity_N2ngb test_gravity_N2ngb.cpp -L. -lsapporo $CUDAINC $CUDALIB $CUDAFLAG $BOOSTINC $BOOSTLIB $BOOSTFLAG
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in &lt;code&gt;compile.sh&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Then run&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;make clean&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;make&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bash compile.sh&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;No go the the starlab folder (&lt;code&gt;cd ../starlab&lt;/code&gt;) and fix the &lt;code&gt;configure&lt;/code&gt; file accordingly to this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#   Check all named libraries for g6_open() (GRAPE-6).

    grape6=no

    for gl in $GRAPE_LIBS_; do
    ##############################
    ######      g2
    ##############################
    CUDAINC=&amp;quot;-I/usr/local/cuda-4.0/include/ -I/usr/local/cuda-4.0/C/common/inc/&amp;quot;
    CUDALIB=&amp;quot;-L/usr/local/cuda-4.0/lib64 -L/usr/local/cuda-4.0/lib:/usr/local/cuda-4.0/C/lib&amp;quot;
    CUDAFLAG=&amp;quot;-lcudart&amp;quot;
    BOOSTINC=&amp;quot;-I/usr/local/x86_64/gnu/boost-1.51.0-gcc4.6/&amp;quot;
    BOOSTLIB=&amp;quot;-L/usr/local/x86_64/gnu/boost-1.51.0-gcc4.6&amp;quot;
    BOOSTFLAG=&amp;quot;-lboost_system  -lboost_thread-mt -lpthread&amp;quot;
    
    LIBS=&amp;quot;$CUDAINC $CUDALIB $CUDAFLAG $BOOSTINC $BOOSTLIB $BOOSTFLAG -DNGB&amp;quot;
        
        
    as_ac_Lib=`echo &amp;quot;ac_cv_lib_${gl/-l/}&#39;&#39;_g6_open_&amp;quot; | $as_tr_sh`

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and the &lt;code&gt;local/grape.sh&lt;/code&gt; file to point to your sapporo installation.&lt;/p&gt;

&lt;p&gt;If you have our version of StarLab, just copy the right files:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cp ../scripts/g2/configure ./&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cp ../scripts/g2/grape.sh ./local/&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Make sure again &lt;code&gt;grape.sh&lt;/code&gt; points to the right folder&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;./configure --without-f77 --with-qt=no&lt;/code&gt; (if you want qt, load the modules and check the versions)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;make clean &amp;amp;&amp;amp; make clean &amp;amp;&amp;amp; make clean&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;make &amp;amp;&amp;amp; make&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rm ./usr/bin/*&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;make install&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;** Troubleshooting **&lt;/p&gt;

&lt;p&gt;If you get this error (or some other error)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make[2]: Entering directory `/mnt/home/bziosi/slpack/starlab/src/gfx/lux&#39;
/bin/sh ../../../libtool --preserve-dup-deps --mode=link gcc  -g -O2  -L/usr/lib64/qt-3.3/lib -o libgfx-2.la   win.lo draw.lo draw1.lo color.lo dialog.lo mcd.lo interface.lo termio.lo utility.lo simple.lo  -I/usr/local/cuda-4.0/include -I/usr/local/cuda-4.0/C/common/inc -L/usr/local/cuda-4.0/lib64 -L/usr/local/cuda-4.0/lib:/usr/local/cuda-4.0/C/lib -lcudart -L/usr/local/x86_64/gnu/boost-1.51.0-gcc4.6 -lboost_system  -lboost_thread-mt -lpthread -DNGB
ar cru .libs/libgfx-2.a  win.o draw.o draw1.o color.o dialog.o mcd.o interface.o termio.o utility.o simple.o
ar: interface.o: No such file or directory
make[2]: *** [libgfx-2.la] Error 1
make[2]: Leaving directory `/mnt/home/bziosi/slpack/starlab/src/gfx/lux&#39;
make[1]: *** [clibs23] Error 2
make[1]: Leaving directory `/mnt/home/bziosi/slpack/starlab/src/gfx&#39;
make: *** [libs] Error 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;when compiling may be you can try to &lt;code&gt;make&lt;/code&gt; and &lt;code&gt;make clean&lt;/code&gt; some times.&lt;br /&gt;
Also remember that make clean is not working properly, so you need to &lt;code&gt;make clean&lt;/code&gt; more than once or delete the binaries by yourself.&lt;/p&gt;

&lt;p&gt;If you have errors regarding no rules for &lt;code&gt;libxhdyn.la&lt;/code&gt;, probably you forgot to exclude
some options from the configure, so run &lt;code&gt;configure --with-f77=no --with-qt=no&lt;/code&gt; or try &lt;code&gt;configure --help&lt;/code&gt;
to check for other options.&lt;/p&gt;

&lt;h3 id=&#34;additional-material:78&#34;&gt;Additional material&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Code units (coming soon&amp;hellip;)&lt;/li&gt;
&lt;li&gt;StarLab internals (TODO)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bitbucket.org/michelis/slpack&#34;&gt;Our repo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/brunetto/sltools&#34;&gt;Tools to easily manage SL runs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.science.uva.nl/sites/modesta/wiki/index.php/Starlab_tools&#34;&gt;StarLab tools wiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.sns.ias.edu/~starlab/tools/auto/&#34;&gt;Auto-built tools list&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>HDF5 in Python: PyTables</title>
      <link>http://brunettoziosi.eu/posts/hdf5-in-python-pytables/</link>
      <pubDate>Fri, 25 May 2012 00:00:00 +0000</pubDate>
      
      <guid>http://brunettoziosi.eu/posts/hdf5-in-python-pytables/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.hdfgroup.org/HDF5/&#34; target=&#34;_blank&#34; title=&#34;HDF5 Group homepage&#34;&gt;HDF5&lt;/a&gt; is a wonderful file format you can use to put into tons of data with easy, without the need to think about endianess, binary formats and so on.&lt;br /&gt;
Pytables is an extremely optimized library built on top of HDF5 capabilities to make even simpler the use of this type of file.&lt;br /&gt;
It&amp;rsquo;s also possible to navigate into a file graphically with &lt;a href=&#34;http://vitables.org/&#34; target=&#34;_blank&#34; title=&#34;ViTables homepage&#34;&gt;ViTables&lt;/a&gt;.&lt;br /&gt;
Here I would like to present some of the features I use more often.&lt;br /&gt;
&lt;!--TEASER_END--&gt;&lt;br /&gt;
Open, flush and close a file&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import tables as tb

h5 = tb.openfile(&amp;quot;filename.h5&amp;quot;, &#39;r&#39;)
...
h5.flush()
h5.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;code&gt;&#39;r&#39;&lt;/code&gt; means &amp;ldquo;open the file in read-only mode&amp;rdquo;. It&amp;rsquo;s also possible to open it as &lt;code&gt;&#39;w&#39;&lt;/code&gt; (create a new file: it overwrites the file if it still exists) and &lt;code&gt;&#39;a&#39;&lt;/code&gt; (append: create if it does not exist, if it exists, read and modify it).&lt;/p&gt;

&lt;p&gt;Create a group to contain some data&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;group = h5.createGroup(h5.root, &amp;quot;group&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;code&gt;h5.root&lt;/code&gt; is the location of the new object created (where we want to create the group) and can also be passe as string (&amp;ldquo;/&amp;rdquo;) and &lt;code&gt;&amp;quot;group&amp;quot;&lt;/code&gt; is the string with the name.&lt;/p&gt;

&lt;p&gt;Store an array&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;a = np.array([....])
array = h5.createArray(h5.root.group, &#39;name&#39;, array_to_store, &#39;title&#39;)
array = h5.createArray(&amp;quot;/group&amp;quot;, &#39;name&#39;, array_to_store, &#39;title&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create a table (from &lt;a href=&#34;create-recreate-and-remove-duplicates-in-array-manipulation-obviously-in-python.html&#34;&gt;Create, recreate and remove duplicates in array manipulation, obviously in Python!:)&lt;/a&gt; or &lt;a href=&#34;from-csv-to-hdf5-in-python.html&#34;&gt;From .csv to HDF5 in Python&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;f = open(&amp;quot;filename.csv&amp;quot;, &#39;r&#39;)
line = f.readline()
values = np.genfromtxt(StringIO(line), dtype=([(&#39;column_1&#39;, &#39;i8&#39;), (&#39;column_2&#39;, &#39;f4&#39;), (&#39;column_3&#39;, &#39;f4&#39;)]), delimiter=&#39;,&#39;)
values.shape = 1

# or in an equivalent way, if the file dimensions permit to lad the entire file:
# values = np.genfromtxt(&amp;quot;filename.csv&amp;quot;, dtype=([(&#39;column_1&#39;, &#39;i8&#39;), (&#39;column_2&#39;, &#39;f4&#39;), (&#39;column_3&#39;, # &#39;f4&#39;)]), delimiter=&#39;,&#39;)

h5 = tb.openFile(&#39;filename.h5&#39;, &#39;w&#39;)
table = h5.createTable(h5.root, description=values, name=&#39;table_name&#39;, title=&amp;quot;table_description&amp;quot;, expectedrows=12158536)
table.flush()

for line in f:
	values = np.genfromtxt(StringIO(line), dtype=([(&#39;column_1&#39;, &#39;i8&#39;), (&#39;column_2&#39;, &#39;f4&#39;), (&#39;column_3&#39;, &#39;f4&#39;)]), delimiter=&#39;,&#39;)
	values.shape = 1
	table.append(values)
	
table.flush()
h5.flush()
h5.close()
f.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s also possible to walk all the nodes under a group:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for i in h5.walkNodes(h5.root.group):
	print i
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and to delete a node/array/table:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;h5.removeNode(h5.root.group, &#39;name&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All the nodes are available through their path:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;h5.getNode(&amp;quot;/group&amp;quot;, &amp;quot;name&amp;quot;)
h5.root.group.name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to read a table or an array, you can use the function &lt;code&gt;read()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;h5.getNode(&amp;quot;/group&amp;quot;, &amp;quot;name&amp;quot;).read()
h5.root.group.name.read()
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Learning C from simulations, #1</title>
      <link>http://brunettoziosi.eu/posts/learning-c-from-simulations-1/</link>
      <pubDate>Mon, 20 Feb 2012 00:00:00 +0000</pubDate>
      
      <guid>http://brunettoziosi.eu/posts/learning-c-from-simulations-1/</guid>
      <description>

&lt;p&gt;Coming from the beauty of Python, now I have to learn C/C++ again (after the course some semesters ago!:P) because of my work. I&amp;rsquo;m doing this working with the simulation code Gadget2 and the ICs (initial conditions) generator N-GenIC. Here I would like to pin the serious and less serious things I&amp;rsquo;m learning for my and maybe other&amp;rsquo;s usefulness and fun!&lt;/p&gt;

&lt;h2 id=&#34;the-ide:98&#34;&gt;The IDE&lt;/h2&gt;

&lt;p&gt;When I write little pieces of code I usually find &lt;a href=&#34;http://kate-editor.org/&#34; target=&#34;_blank&#34; title=&#34;Kate Editor&#34;&gt;Kate&lt;/a&gt; comfortable enough but to explore projects like &lt;a href=&#34;http://www.mpa-garching.mpg.de/gadget/&#34; target=&#34;_blank&#34; title=&#34;Gadget2&#34;&gt;Gadget2&lt;/a&gt; I prefer to use something like &lt;a href=&#34;http://kdevelop.org/&#34; target=&#34;_blank&#34; title=&#34;KDevelop&#34;&gt;KDevelop&lt;/a&gt; because it&amp;rsquo;s easier to manage where a variable is defined, declared and used. And it do this only by positioning the mouse on the variable name. If you put the mouse on a known function (from the standard library for example), KDevelop will open the documentation for you.&lt;/p&gt;

&lt;h2 id=&#34;doxygen:98&#34;&gt;Doxygen&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.stack.nl/~dimitri/doxygen&#34; target=&#34;_blank&#34; title=&#34;Doxygen&#34;&gt;Doxygen&lt;/a&gt; is a documentation system. It allows you to produce documentation for a project from the comments in the code. With no additional work you can &lt;a href=&#34;http://www.stack.nl/~dimitri/doxygen/docblocks.html#specialblock&#34; target=&#34;_blank&#34; title=&#34;Comment in Doxigen&#34;&gt;comment&lt;/a&gt; your code and be ready to produce the documentation. In KDevelop Doxygen style for comments has a different (and nice) coloring.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Single file compilation&lt;/strong&gt;&lt;br /&gt;
I your C program is simple and short, and fit in a single file you can compile it to produce the executable file with&lt;br /&gt;
&lt;pre&gt;gcc -O3 -Wall sort.c -o sort.exe&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;where &lt;code&gt;gcc&lt;/code&gt; is the GNU compiler, &lt;code&gt;-O3&lt;/code&gt; is the level of optimization, &lt;code&gt;-Wall&lt;/code&gt; activate the print of all the warnings, &lt;code&gt;sort.c&lt;/code&gt; is your source code file and &lt;code&gt;-o sort.exe&lt;/code&gt; specify the output file (default is &amp;ldquo;a.out&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve also learned some other things, but a good combination of my laziness and the fact that it&amp;rsquo;s not always useful to rewrite things already well-written let me give you the links to those resources!:)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.network-theory.co.uk/docs/gccintro/gccintro_16.html&#34; target=&#34;_blanck&#34; title=&#34;Makefile&#34;&gt;Makefile&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://duramecho.com/ComputerInformation/WhyCPointers.html&#34; target=&#34;_blank&#34; title=&#34;Why pointers in C&#34;&gt;Pointers&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.cprogramming.com/tutorial/cpreprocessor.html&#34; target=&#34;_blank&#34; title=&#34;Macros&#34;&gt;Macros&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Maybe in the next episodes I will understand how to manage &lt;a href=&#34;http://www.cplusplus.com/forum/articles/10627/&#34; target=&#34;_blank&#34; title=&#34;headers&#34;&gt;headers&lt;/a&gt;, implementations, object files and other funny things!:P&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Learning C from simulations, #3: C horrors!</title>
      <link>http://brunettoziosi.eu/posts/learning-c-from-simulations-3-c-horrors/</link>
      <pubDate>Mon, 20 Feb 2012 00:00:00 +0000</pubDate>
      
      <guid>http://brunettoziosi.eu/posts/learning-c-from-simulations-3-c-horrors/</guid>
      <description>&lt;p&gt;Yeah, this is post #3! Post #2 is &amp;ldquo;work in progress&amp;rdquo; and it will be on FFTs!&lt;/p&gt;

&lt;p&gt;Today I was trying to understand what this piece of code do:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;for(i = 0; i &amp;lt; Nmesh / 2; i++)
    {
      for(j = 0; j &amp;lt; i; j++)
 seedtable[i * Nmesh + j] = 0x7fffffff * gsl_rng_uniform(random_generator);

      for(j = 0; j &amp;lt; i + 1; j++)
 seedtable[j * Nmesh + i] = 0x7fffffff * gsl_rng_uniform(random_generator);

      for(j = 0; j &amp;lt; i; j++)
 seedtable[(Nmesh - 1 - i) * Nmesh + j] = 0x7fffffff * gsl_rng_uniform(random_generator);

      for(j = 0; j &amp;lt; i + 1; j++)
 seedtable[(Nmesh - 1 - j) * Nmesh + i] = 0x7fffffff * gsl_rng_uniform(random_generator);

      for(j = 0; j &amp;lt; i; j++)
 seedtable[i * Nmesh + (Nmesh - 1 - j)] = 0x7fffffff * gsl_rng_uniform(random_generator);

      for(j = 0; j &amp;lt; i + 1; j++)
 seedtable[j * Nmesh + (Nmesh - 1 - i)] = 0x7fffffff * gsl_rng_uniform(random_generator);

      for(j = 0; j &amp;lt; i; j++)
 seedtable[(Nmesh - 1 - i) * Nmesh + (Nmesh - 1 - j)] = 0x7fffffff * gsl_rng_uniform(random_generator);

      for(j = 0; j &amp;lt; i + 1; j++)
 seedtable[(Nmesh - 1 - j) * Nmesh + (Nmesh - 1 - i)] = 0x7fffffff * gsl_rng_uniform(random_generator);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- TEASER_END --&gt;    

&lt;p&gt;It&amp;rsquo;s a piece of the source of N-GenIC, Springel&amp;rsquo;s ICs generator for &lt;a href=&#34;http://www.gadgetcode.org/right.html&#34; target=&#34;_blank&#34; title=&#34;Gadget2&#34;&gt;Gadget2&lt;/a&gt;. Obviously no comments were present and I have no experience of how those codes work. I know that this is a way to fill the &lt;code&gt;seedtable&lt;/code&gt; array, maybe a matrix that provides random seeds for the FFTs or to generate the [latex]delta[/latex]s for the realization of the density field. This array is stored in 1D so to access the elements we have to do some magic with indices. Trying to understand how the matrix is filled and how the indices works, and to practice with C I&amp;rsquo;ve wrote this piece of code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;math.h&amp;gt;

int i = 0, j = 0;
int N = 10;

int main(int argc, char **argv){
  for(i = 0; i &amp;lt; N/2; i++){
    printf(&amp;quot;i = %in&amp;quot;, i);
    for(j = 0; j &amp;lt; i; j++)
      printf(&amp;quot;t j= %in&amp;quot;, j);
      if(!(i * N + j))
 printf(&amp;quot;j doesn&#39;t existn&amp;quot;);
      printf(&amp;quot;tt i * Nmesh + j = %in&amp;quot;,  i * N + j);
  /*
    a lot of commented code from the code above
  */
  }
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The result was&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;i = 0
j doesn&#39;t exist
                 i * Nmesh + j = 0
i = 1
         j= 0
                 i * Nmesh + j = 11
i = 2
         j= 0
         j= 1
                 i * Nmesh + j = 22
i = 3
         j= 0
         j= 1
         j= 2
                 i * Nmesh + j = 33
i = 4
         j= 0
         j= 1
         j= 2
         j= 3
                 i * Nmesh + j = 44
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;clearly wrong.&lt;br /&gt;
So I&amp;rsquo;ve modified the code (thanks to my coworker) to print &lt;code&gt;j&lt;/code&gt; and the expression in both the lines, and the result was&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;i = 0
j doesn&#39;t exist
         j= 0, i * Nmesh + j = 0
i = 1
         j= 0, i * Nmesh + j = 10
         j= 1, i * Nmesh + j = 11
i = 2
         j= 0, i * Nmesh + j = 20
         j= 1, i * Nmesh + j = 21
         j= 2, i * Nmesh + j = 22
i = 3
         j= 0, i * Nmesh + j = 30
         j= 1, i * Nmesh + j = 31
         j= 2, i * Nmesh + j = 32
         j= 3, i * Nmesh + j = 33
i = 4
         j= 0, i * Nmesh + j = 40
         j= 1, i * Nmesh + j = 41
         j= 2, i * Nmesh + j = 42
         j= 3, i * Nmesh + j = 43
         j= 4, i * Nmesh + j = 44
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;wrong again!&lt;/p&gt;

&lt;p&gt;The key is the second &lt;code&gt;for&lt;/code&gt; statement, without the brackets. It was difficult to me to see this because C allows a for statement without brackets evaluating only the first line into the loop, and there were a lot of loop of one line commented into the code. The correct code&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;math.h&amp;gt;

int i = 0, j = 0;
int N = 10;

int main(int argc, char **argv){
  for(i = 0; i &amp;lt; N/2; i++){
    printf(&amp;quot;i = %in&amp;quot;, i);
    for(j = 0; j &amp;lt; i; j++){
      printf(&amp;quot;t j= %i, i * Nmesh + j = %in&amp;quot;, j, i * N + j);
      if(!(i * N + j))
 printf(&amp;quot;j doesn&#39;t existn&amp;quot;);
      printf(&amp;quot;t j= %i, i * Nmesh + j = %in&amp;quot;, j, i * N + j);
  /*
    a lot of commented code from the code above
  */
    }
  }
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;works right!&lt;br /&gt;
Obviously the Python version I&amp;rsquo;ve wrote before was perfect the first time I wrote it.!:P In Python, due to the mandatory indentation (and without those terrible brackets!:P) it&amp;rsquo;s straightforward to understand what belong to a loop and what doesn&amp;rsquo;t!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Loadleveler quick howto</title>
      <link>http://brunettoziosi.eu/posts/loadleveler-quick-howto/</link>
      <pubDate>Fri, 04 Nov 2011 00:00:00 +0000</pubDate>
      
      <guid>http://brunettoziosi.eu/posts/loadleveler-quick-howto/</guid>
      <description>&lt;p&gt;Some useful commands to manage jobs with IBM &lt;code&gt;loadleveler&lt;/code&gt; (&lt;code&gt;ll&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;First of all you need to write a script with some configuration options and the job to be submitted. You can call it (for example) &amp;ldquo;test_run.cmd&amp;rdquo;. With this file you tell &lt;code&gt;ll&lt;/code&gt; what you want to submit, the type of the queue, the directories you need, what you want to be logged and where, the number of parallel tasks and so on.
It would look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
# @ initialdir = /path-to-your-folder
# @ job_name = test_run
# @ output = test_run.$(jobid).out
# @ error = test_run.$(jobid).err
# @ notification = error
# @ class = long
# @ total_tasks = 20
# @ job_type = parallel
# @ queue

ulimit -s 65536

python ./start.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After that you can submit your job with &lt;code&gt;llsubmit test_run.cmd&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Other useful commands are&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;llq -u $USER&lt;/code&gt;: Return information about your jobs only in the queues&lt;/li&gt;
&lt;li&gt;&lt;code&gt;llq -l &amp;amp;lt;job&amp;amp;gt;&lt;/code&gt;: Return detailed information about the specific&lt;/li&gt;
&lt;li&gt;&lt;code&gt;llq -s &amp;amp;lt;job&amp;amp;gt;&lt;/code&gt;: Return information about why the job remains queued&lt;/li&gt;
&lt;li&gt;&lt;code&gt;llcancel &amp;amp;lt;job&amp;amp;gt;&lt;/code&gt;: Cancel a job from the queues, either it is waiting or running&lt;/li&gt;
&lt;li&gt;&lt;code&gt;llstatus&lt;/code&gt;: Return information about the status of the machine&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Reference&lt;/em&gt;: &lt;a href=&#34;http://hpc.cineca.it/content/batch-scheduler-loadleveler&#34; target=&#34;_blank&#34; title=&#34;Cineca LoadLeveler howto&#34;&gt;Cineca LoadLeveler howto&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Python parallel job manager</title>
      <link>http://brunettoziosi.eu/posts/python-parallel-job-manager/</link>
      <pubDate>Fri, 04 Nov 2011 00:00:00 +0000</pubDate>
      
      <guid>http://brunettoziosi.eu/posts/python-parallel-job-manager/</guid>
      <description>&lt;p&gt;The final version of the code for my master thesis was the most embarrassing parallel code you can think&amp;hellip; just a serial code to be run on different slices of the dataset. I choose this solution because it permits to manage the different resources (memory, processors, &amp;hellip;) on the different machines available without any restriction. Moreover, this solution has no communication between the processes, with better performances and all the processes are independent, so it minimize the damages due to any failure.&lt;/p&gt;

&lt;p&gt;At this step, however, I didn&amp;rsquo;t know how to manage the different processes in a comfortable way.
My requirements were:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;to start only one process that will take care of starting the right code on the right data-slice&lt;/li&gt;
&lt;li&gt;the possibility to start &amp;ldquo;n&amp;rdquo; processes depending on the number of processors and memory available (in the actual code this is done by hand)&lt;/li&gt;
&lt;li&gt;the code should be able to start a new process when one of the previous processes end&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Hereafter I expose and comment the complete &amp;ldquo;template&amp;rdquo; for this Python code as I wrote it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/bin/env python

import sys, os
from subprocess import Popen, PIPE
from multiprocessing import Process, Queue

&amp;quot;&amp;quot;&amp;quot;This script starts n_procs processes that in parallel take the
number of the data file from a common queue and with a loop apply the
analysys code to the data starting it with a bash command using Popen
&amp;quot;&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first line is the declaration of the interpreter to be used for this script, in this case Python. After that we import some libraries and modules used in this code. The last lines, inside the triple quotes, are the documentation string of the code. Python in fact has a self-doc system that can be used to understand what a piece of code does and how it works.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;n_procs = 10 # number of processes to be started
file_1 = None
file_2 =  &amp;quot;mill2_fof_sorted.h5&amp;quot;
m_factor = 1    # How many random more than data
start_slice = 0 
end_slice = 99
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we set some parameters: the number of processes to start (set by hand), the two files to use in the analysis, how many random particles we use more than the data particles and the limits in the data slice to analyze. In this case we want to correlate the data in &lt;code&gt;mill2_fof_sorted.h5&lt;/code&gt; with the data contained in the slices between slice 0 and slice 99. file_1 will be replaced after with the right name. This analysis will be carry out using 10 processes at each time. As a process end the code will take care of starting a new process.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def starter(input, output):
	&amp;quot;&amp;quot;&amp;quot;Start the code processes one after the other&amp;quot;&amp;quot;&amp;quot;
	while input.qsize() != 0:
	item = input.get()
	file_1 = &amp;quot;mill2sort-&amp;quot;+str(item[0])       
	cmd = &amp;quot;/opt/epd-7.0-2-rh5-x86_64/bin/python -u \
			../serial.py --file_1 &amp;quot;+file_1+&amp;quot; --file_2 &amp;quot;+file_2+\
		&amp;quot; -l 400 -n 0 --m_factor &amp;quot;+str(m_factor)+&amp;quot; \
			--slicing --log ../logs/&amp;quot;+file_1+&amp;quot;-&amp;quot;+file_2

	try:
		pid = os.getpid()
		pid_cmd = &#39;echo &amp;quot;&#39;+str(item[0])+&#39;&amp;quot; &amp;amp;gt;&amp;amp;gt; &#39;+str(pid)+&#39;.log&#39;
		os.system(pid_cmd)
		p = Popen(cmd, shell=True, close_fds=True).wait()

	except:
		print &amp;quot;Popen/os.system not done, exit...&amp;quot;
		sys.exit()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This piece of code defines the function that will start the processes. It&amp;rsquo;s called &lt;code&gt;started&lt;/code&gt; and it takes &lt;code&gt;input&lt;/code&gt; and &lt;code&gt;output&lt;/code&gt; as arguments. These are two &amp;ldquo;queue objects&amp;rdquo;, they can be filled and emptied in the FIFO way. The starter has a while loop that check if the queue is empty, if not it takes the next elements. This is the number of the slice to be used by the analysis code and with it we build the name of the file to be opened. &lt;code&gt;cmd&lt;/code&gt; is the string we use to start the analysis code with some options (&lt;code&gt;serial.py&lt;/code&gt; is the actual &amp;ldquo;cool&amp;rdquo; name I gave to my code!:P).&lt;br /&gt;
The &lt;code&gt;try-exept&lt;/code&gt; syntax is the particular Python way to manage the possible errors in the execution, giving the ability to the programmer to handle possible problems (exceptions).&lt;br /&gt;
So we catch the pid of the starter and save into its log the number of sliced it start and pass to the &lt;code&gt;Popen&lt;/code&gt; (process-open) command the string to start the analysis process telling it to wait the end of the process. If something goes wrong we print that there were some errors and exit the code in a clean way.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def fill_queue(task_queue, start_slice, end_slice):
	&amp;quot;&amp;quot;&amp;quot;Fill the queue&amp;quot;&amp;quot;&amp;quot;
	for i in range(start_slice, end_slice, 1):
		task_queue.put([i])
	return task_queue
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This functions only fill the queue with the number of the sliced to be used.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def status(proc):
	&amp;quot;&amp;quot;&amp;quot;Check for processes status&amp;quot;&amp;quot;&amp;quot;
	if proc.is_alive()==True:
		return &#39;alive&#39;
	elif proc.is_alive()==False:
		return &#39;dead&#39;
	else:
		return proc.is_alive()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This piece of code check the status (dead or alive) of one process (&lt;code&gt;proc&lt;/code&gt; is the process object&amp;hellip; yeah, in Python everything is an object!)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;input_queue = Queue()
output_queue = Queue()

try:
    input_queue = fill_queue(input_queue, start_slice, end_slice)
except:
    print &amp;quot;Queue not filled, exit...&amp;quot;
    sys.exit()

procs = []    # processes container
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we create the empty queues and (try to) fill them, and create the container for the processes objects.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;try:
    for i in range(n_procs):
        print &amp;quot;Process loop &amp;quot;, i
        procs.append(Process(target=starter, args=(input_queue, output_queue)))
except:
    print &amp;quot;Creating processes not complete, exit...&amp;quot;
    sys.exit()

try:
    for i in procs:
        i.start()
except:
    print &amp;quot;Start processes not complete, exit...&amp;quot;
    sys.exit()

for i in procs:
    print &amp;quot;Process &amp;quot;, i,&amp;quot; @ &amp;quot; , i.pid, &amp;quot; is &amp;quot;, status(i)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is the central part of this code: we create the processes objects and put them into the container, start them and check for their status. Everything is inside the &lt;code&gt;try-except&lt;/code&gt; environment to check for possible errors and handle them.&lt;br /&gt;
In practice we start &amp;ldquo;n&amp;rdquo; processes and every process take the number of a slice from the queue and use it to start the analysis code, waiting for its end. When the analysis is finished it takes another number from the queue and start again the code. When the queue is empty everything is automatically switched off.&lt;br /&gt;
Future improvements will consider the automatically detection of the hardware resources and the possibility to mail the status of the code.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>