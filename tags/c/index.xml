<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C on Post It!</title>
    <link>http://brunettoziosi.eu/tags/c/</link>
    <description>Recent content in C on Post It!</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 21 May 2012 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://brunettoziosi.eu/tags/c/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Learning not to hate C: things worth nothing</title>
      <link>http://brunettoziosi.eu/posts/learning-not-to-hate-c-things-worth-nothing/</link>
      <pubDate>Mon, 21 May 2012 00:00:00 +0000</pubDate>
      
      <guid>http://brunettoziosi.eu/posts/learning-not-to-hate-c-things-worth-nothing/</guid>
      <description>

&lt;p&gt;Here I would like to post some of the ideas, tricks, truths, and so on I&amp;rsquo;ve learned during the two-days course at the computing center. Two intense days of base C-programming full immersion, far beyond the flat and boring (and unuseful) orthodoxy you can find in a book.&lt;/p&gt;

&lt;h2 id=&#34;header-files:89&#34;&gt;Header files&lt;/h2&gt;

&lt;p&gt;They are one of the first annoying things I see in C/C++ languages. Two files for each &amp;ldquo;module&amp;rdquo;, two lines to be modified every times, &amp;hellip; but I have eventually obtained a reasonable justification for their existence. When you distribute your code, or download someone&amp;rsquo;s code, you can share or download compiled code+header files and not all the sources.&lt;/p&gt;

&lt;h2 id=&#34;compile:89&#34;&gt;Compile&lt;/h2&gt;

&lt;p&gt;The easiest way to compile the sources and get the executable is&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;gcc pippo.c -o pippo.x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;code&gt;pippo.c&lt;/code&gt; is the source(s) (you can have &lt;code&gt;pippo1.c&lt;/code&gt;, &lt;code&gt;pippo2.c&lt;/code&gt; etc, but only one &lt;code&gt;main&lt;/code&gt; function) file.&lt;br /&gt;
A better way is to include some flags&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;gcc -std=gnu99 -Wall -pedantic -Werror -O0 -g -o pippo.x pippo.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-std=gnu99&lt;/code&gt; forces the compiler to the C99 standard (it includes some new features)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-Wall&lt;/code&gt; to print all the compiler warnings&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-pedantic&lt;/code&gt; &amp;ldquo;Issue all the warnings demanded by strict ISO C and ISO C++; reject all programs that use forbidden extensions, and some other programs that do not follow ISO C and ISO C++&amp;rdquo; (from the &lt;code&gt;gcc&lt;/code&gt; manual)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-Werror&lt;/code&gt; transform the warnings into errors&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-O0&lt;/code&gt; no optimization&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-g&lt;/code&gt; produces debugging informations&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-o&lt;/code&gt; to specify the output&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;macros-preprocessor:89&#34;&gt;MACROS &amp;amp; preprocessor&lt;/h2&gt;

&lt;p&gt;The preprocessor is a sort of automated text editor. It cut and paste piece of text in the sources files according to some simple rules. With it you can define &amp;ldquo;constant&amp;rdquo; values or simple functions (danger, can lead to unpredicted effects) across the whole source and make easy to change it&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#define PI 3.14
float a = PI;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but you can also check for already defined quantities, compile pieces of code (&amp;ldquo;conditional compilation&amp;rdquo;) or implement a &amp;ldquo;header-guard&amp;rdquo; to avoid multiple imports of the same header&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#define CONDITION
#ifdef CONDITION
....
#else
....
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#ifndef HEADER_H
#define HEADER_H
.....
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Compiling with the &lt;code&gt;-E&lt;/code&gt; flag you can view the result of the preprocessor action.&lt;/p&gt;

&lt;h2 id=&#34;numbers:89&#34;&gt;Numbers&lt;/h2&gt;

&lt;p&gt;Number variables are similar to those in other programming languages, but there&amp;rsquo;s some peculiarities.&lt;br /&gt;
Integer dimension depends on the machine and on the compiler, on the contrary floats and doubles are fixed by an international standard. For the rest you can find detailed description on every C books.&lt;/p&gt;

&lt;h2 id=&#34;cast:89&#34;&gt;Cast&lt;/h2&gt;

&lt;p&gt;It&amp;rsquo;s possible to convert one type to some other type. For example,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;float pippo;
pippo = (float) k*1024L;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;bool:89&#34;&gt;Bool&lt;/h2&gt;

&lt;p&gt;There aren&amp;rsquo;t boolean variables, but 0 stands for &lt;code&gt;False&lt;/code&gt; and any other non-zero value means &lt;code&gt;True&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;side-effect-and-short-circuit:89&#34;&gt;Side effect and short-circuit&lt;/h2&gt;

&lt;p&gt;Something like&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;i = k + 10 - ++k;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;has indefinite result because it&amp;rsquo;s not predictable the order of evaluation of operand/expression &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;++k&lt;/code&gt;, and those expressions have &lt;em&gt;side effects&lt;/em&gt; on the other expression involved in the result.&lt;br /&gt;
Logical operators &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; instead are evaluated strictly from left to right. This is c&lt;em&gt;alled short-circuit evaluation&lt;/em&gt; and the operators are synchronization points, just like &amp;ldquo;;&amp;rdquo;. At a synchronization point all the code before has to be already evaluated and the code after has not yet.&lt;/p&gt;

&lt;h2 id=&#34;ternary-operator:89&#34;&gt;Ternary operator&lt;/h2&gt;

&lt;p&gt;The ternary operator accept three arguments and has the form of&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;result = a &amp;amp;gt; b ? x : y;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This means &lt;code&gt;[expression_to_evaluate] ? [if true] : [if false]&lt;/code&gt;. Obviously you can nest as many expression and operator as you want.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Variables qualifiers&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;In C there&amp;rsquo;are some qualifier that can be added to the type specification. Three of them are &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;extern&lt;/code&gt; and &lt;code&gt;static&lt;/code&gt;.&lt;br /&gt;
The first can be added in the function declaration to tell the compiler that the values has not to be changed by the function, for example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;int pippo(const int pluto, const int* paperino);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;means that the integer &lt;code&gt;pluto&lt;/code&gt; and the pointer to integer &lt;code&gt;paperino&lt;/code&gt; can not be changed by the function &lt;code&gt;pippo&lt;/code&gt;.&lt;br /&gt;
&amp;ldquo;extern&amp;rdquo; specifies that the variable is a global variable, coming from outside the function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;int pippo;
int main(...){
	extern int pippo;
...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;ldquo;static&amp;rdquo; has different meanings depending on where you put it.&lt;br /&gt;
Before a global variable means that the variable is private of the file, and other files can not use it. Inside a function means that the variable survive after the end of the function (when the stack frame - the stack memory associated to the function - is deleted) and is available to the succeeding calls to the same function. Static is also used before a function to specify that the function is private of the file and can not be called outside:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;static int i;
static void foo(void){
	extern int i;
	static int j
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt; is global inside the file but can not be called outside&lt;/li&gt;
&lt;li&gt;the function &lt;code&gt;foo&lt;/code&gt; is private of the file and can not be called outside&lt;/li&gt;
&lt;li&gt;&lt;code&gt;j&lt;/code&gt; survive after the termination of the function and maintains its value until the next call.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Pointers&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Pointers are special integer values that contains addresses of other values, for example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;int i;
int* p;
p = &amp;amp;amp;i;
*p = 13;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;first we define the integer &lt;code&gt;i&lt;/code&gt;, then a pointer &lt;code&gt;p&lt;/code&gt; to a integer value (here &lt;code&gt;*&lt;/code&gt; means &amp;ldquo;the argument on the right is a pointer to a value of type defined by the argument on the left&amp;rdquo;), then we put the address of &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;p&lt;/code&gt; (&lt;code&gt;&amp;amp;amp;&lt;/code&gt; means &amp;ldquo;give me the address of the right argument&amp;rdquo;) and at the end we modify the value of &lt;code&gt;i&lt;/code&gt; dereferencing &lt;code&gt;p&lt;/code&gt;, that is modifying the memory cell pointed by the address contained in p (here &lt;code&gt;*&lt;/code&gt; means &amp;ldquo;follow the address contained in the argument on the right&amp;rdquo;).&lt;br /&gt;
It&amp;rsquo;s possible to define pointers to pointers to pointers etc. adding &amp;ldquo;*&amp;ldquo;. It exists the null pointer, that is an invalid pointer, and follow it result in a &amp;ldquo;segmentation fault&amp;rdquo; that means &amp;ldquo;you are trying to access memory you are not allowed to access&amp;rdquo;. A pointer defined but not filled point to a random location in memory, so following it results in an indefinite result, probably a segmentation fault or the modification of another variable.&lt;br /&gt;
Because the dereferencing operator has not the highest precedence, sometimes you will have to put parenthesis to specify the order of dereferencing:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;/*Filling a &amp;quot;heap&amp;quot; array using pointers*/
(*ptr)[i] = (float*) malloc(sizeof(float)*lenghtx);

/*In struct, the two forms are equivalent*/
(*pippo).pluto
pippo-&amp;amp;gt;pluto
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;stack-and-heap:89&#34;&gt;Stack and heap&lt;/h2&gt;

&lt;p&gt;The stack is the automatic memory used for the function calls, their local variables and the automatic arrays. It&amp;rsquo;s managed automatically. The heap is the memory available to the user to define his variables. This has to be managed by the user so he has to deallocate the allocated memory and to keep track of the pointers (address). If you loose the pointer to some allocated memory this is lost until the end of the program and the memory can saturate. This is known as &amp;ldquo;&lt;em&gt;memory leak&lt;/em&gt;&amp;rdquo;.&lt;/p&gt;

&lt;h2 id=&#34;arrays:89&#34;&gt;Arrays&lt;/h2&gt;

&lt;p&gt;There&amp;rsquo;are basically two ways to create an array. First, you can create an automatic array in the stack memory, managed by the compiler. For this reason automatic arrays must be small and have to be defined at compile time, that means that you have to know and declare the dimension, for example;&lt;/p&gt;

&lt;pre&gt;float array[10];&lt;/pre&gt;
    

&lt;p&gt;You can access the elements of the array in the natural way &lt;code&gt;array[3] = 10&lt;/code&gt;.&lt;br /&gt;
As a matter of fact, because an array it&amp;rsquo;s a masked pointer, all of these are equivalent&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;*V = 10;
V[0] = 10;
*(V+0) = 10;
0[V] = 10;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The operator &amp;ldquo;&lt;code&gt;[]&lt;/code&gt;&amp;rdquo; is equivalent to dereferencing the address contained into the pointer on the left shifted by the quantity inside the operator, and to shift an address is equivalent to sum it to the shift because addresses are integer values and the memory occupied by an array is contiguous.&lt;/p&gt;

&lt;p&gt;The second type of array is defined by the user and manually allocated (and manually deallocated) in the heap memory with&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;void* malloc(size_t size);
void free(void* heapBlockPointer);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In practice, the following is an example of how to implement two functions that create and destroy a two dimensional array given a pointer:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#include 
#include 
#include &amp;quot;array_management.h&amp;quot;

/* Function definition, takes as argument the address of a pointer to pointer */
int array_creation(float*** ptr, int lenghtx, int lenghty){
	printf(&amp;quot;Create array of pointers...n&amp;quot;);

	/* In the memory cell of the pointer put the address of the first 
		element of an array of pointers to float and allocate the necessary space */
	*ptr = (float**) malloc(sizeof(float*)*lenghty); 

	/* Check that the allocation worked fine */
	if(*ptr==NULL){
	return -1;
	}
	printf(&amp;quot;Create arrays...n&amp;quot;);

	/* Allocate memory for an array of float for each pointer and put the address 
		of the first element in the respective cell of the array of pointers */
	for(int i=0; i&amp;amp;lt;lenghty; i++){
	(*ptr)[i] = (float*) malloc(sizeof(float)*lenghtx);
	if( (*ptr)[i] == NULL){
		return -1;
	}
	}
	return 0;
}

/* Function to deallocate the memory */
void array_destruction(float** ptr, int lenghty){
	printf(&amp;quot;Destructing array...n&amp;quot;);
	for(int i=0; i&amp;amp;lt;lenghty; i++){
	free(ptr[i]);
	}
	free(ptr); 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In both types of array there isn&amp;rsquo;t a control on the indexes, it&amp;rsquo;s up to the user not to read or write beyond the array limits.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s also important to keep in mind that arrays are contiguous memory blocks, and a multidimensional array is &amp;ldquo;linearized&amp;rdquo; row-major order so it&amp;rsquo;s faster to &amp;ldquo;run&amp;rdquo; on the row index (that on the right-most one). This is known as &lt;a href=&#34;http://en.wikipedia.org/wiki/Stride_of_an_array&#34; target=&#34;_blank&#34;&gt;stride one access&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;structs:89&#34;&gt;Structs&lt;/h2&gt;

&lt;p&gt;An array is a structure containing homogeneous data, if you need to put together different types of data you can use structs:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;struct point {
int x;
int y;}; /* Don&#39;t forget this semicolon!*/

struct point pippo;
pippo.x = 12;
pippo.y = 15;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s also possible to use &lt;code&gt;typedef&lt;/code&gt; to symplify the sintax:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;typedef struct treenode* Tree;
struct treenode {
int data;
Tree smaller, larger; /* equivalently, this line could say
};                       &amp;quot;struct treenode *smaller, *larger&amp;quot; */  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(From Cineca&amp;rsquo;s slides)&lt;/p&gt;

&lt;h2 id=&#34;strings:89&#34;&gt;Strings&lt;/h2&gt;

&lt;p&gt;Strings are simply arrays of characters, usually terminated with the &amp;ldquo;null&amp;rdquo; character &amp;ldquo;&lt;code&gt;&amp;quot; to be able to use the string manipulation libraries (without &amp;quot;&lt;/code&gt;&amp;rdquo; you should give the length of the string to the library, but they are not designed to do this).&lt;br /&gt;
Because of this, the two expression that follows are equivalent:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;void strcpy(char *s, char *t) {
	while ((*s = *t) != ‘’) {
	s++;
	t++;
	}
}
void strcpy(char s[], char *t) {
	/* s arr, t ptr */
	int i = 0;
	while ((*s = t[i]) != ‘’) {
	s++; /* s ptr */
	i++; /* t arr */
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(From Cineca&amp;rsquo;s slides)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Assignement evaluation&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Because the assignment operator &amp;ldquo;=&amp;rdquo; return the value assigned, it&amp;rsquo;s possible to use this in expression evaluation to shorten the code, for example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;void strcpy(char *s, char *t){while((*s++==*t++));}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is equivalent to the expressions in the previous paragraph.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Learning C from simulations, #1</title>
      <link>http://brunettoziosi.eu/posts/learning-c-from-simulations-1/</link>
      <pubDate>Mon, 20 Feb 2012 00:00:00 +0000</pubDate>
      
      <guid>http://brunettoziosi.eu/posts/learning-c-from-simulations-1/</guid>
      <description>

&lt;p&gt;Coming from the beauty of Python, now I have to learn C/C++ again (after the course some semesters ago!:P) because of my work. I&amp;rsquo;m doing this working with the simulation code Gadget2 and the ICs (initial conditions) generator N-GenIC. Here I would like to pin the serious and less serious things I&amp;rsquo;m learning for my and maybe other&amp;rsquo;s usefulness and fun!&lt;/p&gt;

&lt;h2 id=&#34;the-ide:100&#34;&gt;The IDE&lt;/h2&gt;

&lt;p&gt;When I write little pieces of code I usually find &lt;a href=&#34;http://kate-editor.org/&#34; target=&#34;_blank&#34; title=&#34;Kate Editor&#34;&gt;Kate&lt;/a&gt; comfortable enough but to explore projects like &lt;a href=&#34;http://www.mpa-garching.mpg.de/gadget/&#34; target=&#34;_blank&#34; title=&#34;Gadget2&#34;&gt;Gadget2&lt;/a&gt; I prefer to use something like &lt;a href=&#34;http://kdevelop.org/&#34; target=&#34;_blank&#34; title=&#34;KDevelop&#34;&gt;KDevelop&lt;/a&gt; because it&amp;rsquo;s easier to manage where a variable is defined, declared and used. And it do this only by positioning the mouse on the variable name. If you put the mouse on a known function (from the standard library for example), KDevelop will open the documentation for you.&lt;/p&gt;

&lt;h2 id=&#34;doxygen:100&#34;&gt;Doxygen&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.stack.nl/~dimitri/doxygen&#34; target=&#34;_blank&#34; title=&#34;Doxygen&#34;&gt;Doxygen&lt;/a&gt; is a documentation system. It allows you to produce documentation for a project from the comments in the code. With no additional work you can &lt;a href=&#34;http://www.stack.nl/~dimitri/doxygen/docblocks.html#specialblock&#34; target=&#34;_blank&#34; title=&#34;Comment in Doxigen&#34;&gt;comment&lt;/a&gt; your code and be ready to produce the documentation. In KDevelop Doxygen style for comments has a different (and nice) coloring.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Single file compilation&lt;/strong&gt;&lt;br /&gt;
I your C program is simple and short, and fit in a single file you can compile it to produce the executable file with&lt;br /&gt;
&lt;pre&gt;gcc -O3 -Wall sort.c -o sort.exe&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;where &lt;code&gt;gcc&lt;/code&gt; is the GNU compiler, &lt;code&gt;-O3&lt;/code&gt; is the level of optimization, &lt;code&gt;-Wall&lt;/code&gt; activate the print of all the warnings, &lt;code&gt;sort.c&lt;/code&gt; is your source code file and &lt;code&gt;-o sort.exe&lt;/code&gt; specify the output file (default is &amp;ldquo;a.out&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve also learned some other things, but a good combination of my laziness and the fact that it&amp;rsquo;s not always useful to rewrite things already well-written let me give you the links to those resources!:)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.network-theory.co.uk/docs/gccintro/gccintro_16.html&#34; target=&#34;_blanck&#34; title=&#34;Makefile&#34;&gt;Makefile&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://duramecho.com/ComputerInformation/WhyCPointers.html&#34; target=&#34;_blank&#34; title=&#34;Why pointers in C&#34;&gt;Pointers&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.cprogramming.com/tutorial/cpreprocessor.html&#34; target=&#34;_blank&#34; title=&#34;Macros&#34;&gt;Macros&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Maybe in the next episodes I will understand how to manage &lt;a href=&#34;http://www.cplusplus.com/forum/articles/10627/&#34; target=&#34;_blank&#34; title=&#34;headers&#34;&gt;headers&lt;/a&gt;, implementations, object files and other funny things!:P&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Learning C from simulations, #3: C horrors!</title>
      <link>http://brunettoziosi.eu/posts/learning-c-from-simulations-3-c-horrors/</link>
      <pubDate>Mon, 20 Feb 2012 00:00:00 +0000</pubDate>
      
      <guid>http://brunettoziosi.eu/posts/learning-c-from-simulations-3-c-horrors/</guid>
      <description>&lt;p&gt;Yeah, this is post #3! Post #2 is &amp;ldquo;work in progress&amp;rdquo; and it will be on FFTs!&lt;/p&gt;

&lt;p&gt;Today I was trying to understand what this piece of code do:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;for(i = 0; i &amp;lt; Nmesh / 2; i++)
    {
      for(j = 0; j &amp;lt; i; j++)
 seedtable[i * Nmesh + j] = 0x7fffffff * gsl_rng_uniform(random_generator);

      for(j = 0; j &amp;lt; i + 1; j++)
 seedtable[j * Nmesh + i] = 0x7fffffff * gsl_rng_uniform(random_generator);

      for(j = 0; j &amp;lt; i; j++)
 seedtable[(Nmesh - 1 - i) * Nmesh + j] = 0x7fffffff * gsl_rng_uniform(random_generator);

      for(j = 0; j &amp;lt; i + 1; j++)
 seedtable[(Nmesh - 1 - j) * Nmesh + i] = 0x7fffffff * gsl_rng_uniform(random_generator);

      for(j = 0; j &amp;lt; i; j++)
 seedtable[i * Nmesh + (Nmesh - 1 - j)] = 0x7fffffff * gsl_rng_uniform(random_generator);

      for(j = 0; j &amp;lt; i + 1; j++)
 seedtable[j * Nmesh + (Nmesh - 1 - i)] = 0x7fffffff * gsl_rng_uniform(random_generator);

      for(j = 0; j &amp;lt; i; j++)
 seedtable[(Nmesh - 1 - i) * Nmesh + (Nmesh - 1 - j)] = 0x7fffffff * gsl_rng_uniform(random_generator);

      for(j = 0; j &amp;lt; i + 1; j++)
 seedtable[(Nmesh - 1 - j) * Nmesh + (Nmesh - 1 - i)] = 0x7fffffff * gsl_rng_uniform(random_generator);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- TEASER_END --&gt;    

&lt;p&gt;It&amp;rsquo;s a piece of the source of N-GenIC, Springel&amp;rsquo;s ICs generator for &lt;a href=&#34;http://www.gadgetcode.org/right.html&#34; target=&#34;_blank&#34; title=&#34;Gadget2&#34;&gt;Gadget2&lt;/a&gt;. Obviously no comments were present and I have no experience of how those codes work. I know that this is a way to fill the &lt;code&gt;seedtable&lt;/code&gt; array, maybe a matrix that provides random seeds for the FFTs or to generate the [latex]delta[/latex]s for the realization of the density field. This array is stored in 1D so to access the elements we have to do some magic with indices. Trying to understand how the matrix is filled and how the indices works, and to practice with C I&amp;rsquo;ve wrote this piece of code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;math.h&amp;gt;

int i = 0, j = 0;
int N = 10;

int main(int argc, char **argv){
  for(i = 0; i &amp;lt; N/2; i++){
    printf(&amp;quot;i = %in&amp;quot;, i);
    for(j = 0; j &amp;lt; i; j++)
      printf(&amp;quot;t j= %in&amp;quot;, j);
      if(!(i * N + j))
 printf(&amp;quot;j doesn&#39;t existn&amp;quot;);
      printf(&amp;quot;tt i * Nmesh + j = %in&amp;quot;,  i * N + j);
  /*
    a lot of commented code from the code above
  */
  }
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The result was&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;i = 0
j doesn&#39;t exist
                 i * Nmesh + j = 0
i = 1
         j= 0
                 i * Nmesh + j = 11
i = 2
         j= 0
         j= 1
                 i * Nmesh + j = 22
i = 3
         j= 0
         j= 1
         j= 2
                 i * Nmesh + j = 33
i = 4
         j= 0
         j= 1
         j= 2
         j= 3
                 i * Nmesh + j = 44
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;clearly wrong.&lt;br /&gt;
So I&amp;rsquo;ve modified the code (thanks to my coworker) to print &lt;code&gt;j&lt;/code&gt; and the expression in both the lines, and the result was&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;i = 0
j doesn&#39;t exist
         j= 0, i * Nmesh + j = 0
i = 1
         j= 0, i * Nmesh + j = 10
         j= 1, i * Nmesh + j = 11
i = 2
         j= 0, i * Nmesh + j = 20
         j= 1, i * Nmesh + j = 21
         j= 2, i * Nmesh + j = 22
i = 3
         j= 0, i * Nmesh + j = 30
         j= 1, i * Nmesh + j = 31
         j= 2, i * Nmesh + j = 32
         j= 3, i * Nmesh + j = 33
i = 4
         j= 0, i * Nmesh + j = 40
         j= 1, i * Nmesh + j = 41
         j= 2, i * Nmesh + j = 42
         j= 3, i * Nmesh + j = 43
         j= 4, i * Nmesh + j = 44
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;wrong again!&lt;/p&gt;

&lt;p&gt;The key is the second &lt;code&gt;for&lt;/code&gt; statement, without the brackets. It was difficult to me to see this because C allows a for statement without brackets evaluating only the first line into the loop, and there were a lot of loop of one line commented into the code. The correct code&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;math.h&amp;gt;

int i = 0, j = 0;
int N = 10;

int main(int argc, char **argv){
  for(i = 0; i &amp;lt; N/2; i++){
    printf(&amp;quot;i = %in&amp;quot;, i);
    for(j = 0; j &amp;lt; i; j++){
      printf(&amp;quot;t j= %i, i * Nmesh + j = %in&amp;quot;, j, i * N + j);
      if(!(i * N + j))
 printf(&amp;quot;j doesn&#39;t existn&amp;quot;);
      printf(&amp;quot;t j= %i, i * Nmesh + j = %in&amp;quot;, j, i * N + j);
  /*
    a lot of commented code from the code above
  */
    }
  }
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;works right!&lt;br /&gt;
Obviously the Python version I&amp;rsquo;ve wrote before was perfect the first time I wrote it.!:P In Python, due to the mandatory indentation (and without those terrible brackets!:P) it&amp;rsquo;s straightforward to understand what belong to a loop and what doesn&amp;rsquo;t!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>