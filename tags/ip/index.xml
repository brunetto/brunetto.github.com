<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ip on Post It!</title>
    <link>http://brunettoziosi.eu/tags/ip/</link>
    <description>Recent content in Ip on Post It!</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 03 Sep 2013 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://brunettoziosi.eu/tags/ip/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Check external ip</title>
      <link>http://brunettoziosi.eu/posts/check-external-ip/</link>
      <pubDate>Tue, 03 Sep 2013 00:00:00 +0000</pubDate>
      
      <guid>http://brunettoziosi.eu/posts/check-external-ip/</guid>
      <description>

&lt;p&gt;This is the first attempt to check the external ip of a linux box.
This means, for example, the public ip address of our modem if we are connected
to the home Wi-Fi.&lt;br /&gt;
I will try to do this in Python and Go. Of course these are raw attempts.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Update:&lt;/strong&gt; new version &lt;a href=&#34;https://github.com/brunetto/fip&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;python:31&#34;&gt;Python&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
import re, os, time

# In internet they say that
# ^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$
# is better but I find this useful

print &amp;quot;Check external ip&amp;quot;
print &amp;quot;This script need curl and the Python modules re, os and time&amp;quot;

# Compile regex
reg = re.compile(&#39;\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}&#39;)

# Query until stop, hoping the site won&#39;t stop us
while True:
	# Ask the site for ip
	string = os.popen(&amp;quot;curl -s &#39;http://checkip.dyndns.org&#39;&amp;quot;).read()
	res = reg.search(string)
	if res == None:
		print &amp;quot;Error, ip not found, continue, ...&amp;quot;
	else:
		print ip
		ip = res.group(0)
		# Recreate the ip file and write the ip
		ipFile = open(&amp;quot;ip.dat&amp;quot;, &#39;w&#39;)
		ipFile.write(ip)
		ipFile.flush()
		ipFile.close()
	# Wait
	time.sleep(5)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;go:31&#34;&gt;Go&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	//&amp;quot;io/ioutil&amp;quot;
    &amp;quot;os&amp;quot;
    &amp;quot;log&amp;quot;
    &amp;quot;fmt&amp;quot;
    &amp;quot;time&amp;quot;
    &amp;quot;os/exec&amp;quot;
    &amp;quot;regexp&amp;quot;
)

// check the errors
func check(e error) {
    if e != nil {
        panic(e)
    }
}

func main() {

	// set ip download command
	
	command := &amp;quot;/usr/bin/curl&amp;quot;
	args := &amp;quot;http://checkip.dyndns.org&amp;quot;
	
	// compile regexp
	var digitsRegexp = regexp.MustCompile(`\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}`)
	
	// infinite loop to update the ip
    for ;;{
		// download ip string
		out, err := exec.Command(command, args).Output()
		if err != nil {
			log.Fatal(err)
		}
		
		// out is a binary buffer, convert into string
		ipString := string(out)
		
		// search for ip
		ipRes := digitsRegexp.FindString(ipString)
		fmt.Println(ipRes)
		
		// convert string to byte (found a better method)
		//ipByte := []byte(ipRes)
		//ioutil.WriteFile(&amp;quot;ip.dat&amp;quot;, ipByte, 0644)
		
		// create a file, it implements the Writer interface
		f, err := os.Create(&amp;quot;ip.dat&amp;quot;)
		
		// check for errors
		check(err)
		
		// close file before exit in case of problems
		defer f.Close()
		
		// write the string, discard (_) the number of bytes written
		_, err = f.WriteString(ipRes)
		// flush 
		f.Sync()
		f.Close()
		// wait
		time.Sleep(5 * time.Second)
    }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>